// WARNING: DO NOT EDIT THIS FILE. THIS FILE IS MANAGED BY SPRING ROO.
// You may push code into the target .java compilation unit if you wish to edit any member(s).

package com.ug.domain;

import com.ug.domain.Grantneededfor;
import com.ug.domain.Loan;
import com.ug.domain.Loanstatus;
import com.ug.domain.User;
import java.lang.Long;
import java.lang.String;
import java.math.BigDecimal;
import java.util.Date;
import javax.persistence.EntityManager;
import javax.persistence.TypedQuery;

privileged aspect Loan_Roo_Finder {
    
    public static TypedQuery<Loan> Loan.findLoansByGrantNeededFor(Grantneededfor grantNeededFor) {
        if (grantNeededFor == null) throw new IllegalArgumentException("The grantNeededFor argument is required");
        EntityManager em = Loan.entityManager();
        TypedQuery<Loan> q = em.createQuery("SELECT Loan FROM Loan AS loan WHERE loan.grantNeededFor = :grantNeededFor", Loan.class);
        q.setParameter("grantNeededFor", grantNeededFor);
        return q;
    }
    
    public static TypedQuery<Loan> Loan.findLoansByLastupdatedby(Long lastupdatedby) {
        if (lastupdatedby == null) throw new IllegalArgumentException("The lastupdatedby argument is required");
        EntityManager em = Loan.entityManager();
        TypedQuery<Loan> q = em.createQuery("SELECT Loan FROM Loan AS loan WHERE loan.lastupdatedby = :lastupdatedby", Loan.class);
        q.setParameter("lastupdatedby", lastupdatedby);
        return q;
    }
    
    public static TypedQuery<Loan> Loan.findLoansByLastupdatedtimestamp(Date lastupdatedtimestamp) {
        if (lastupdatedtimestamp == null) throw new IllegalArgumentException("The lastupdatedtimestamp argument is required");
        EntityManager em = Loan.entityManager();
        TypedQuery<Loan> q = em.createQuery("SELECT Loan FROM Loan AS loan WHERE loan.lastupdatedtimestamp = :lastupdatedtimestamp", Loan.class);
        q.setParameter("lastupdatedtimestamp", lastupdatedtimestamp);
        return q;
    }
    
    public static TypedQuery<Loan> Loan.findLoansByLastupdatedtimestampBetween(Date minLastupdatedtimestamp, Date maxLastupdatedtimestamp) {
        if (minLastupdatedtimestamp == null) throw new IllegalArgumentException("The minLastupdatedtimestamp argument is required");
        if (maxLastupdatedtimestamp == null) throw new IllegalArgumentException("The maxLastupdatedtimestamp argument is required");
        EntityManager em = Loan.entityManager();
        TypedQuery<Loan> q = em.createQuery("SELECT Loan FROM Loan AS loan WHERE loan.lastupdatedtimestamp BETWEEN :minLastupdatedtimestamp AND :maxLastupdatedtimestamp", Loan.class);
        q.setParameter("minLastupdatedtimestamp", minLastupdatedtimestamp);
        q.setParameter("maxLastupdatedtimestamp", maxLastupdatedtimestamp);
        return q;
    }
    
    public static TypedQuery<Loan> Loan.findLoansByLastupdatedtimestampGreaterThan(Date lastupdatedtimestamp) {
        if (lastupdatedtimestamp == null) throw new IllegalArgumentException("The lastupdatedtimestamp argument is required");
        EntityManager em = Loan.entityManager();
        TypedQuery<Loan> q = em.createQuery("SELECT Loan FROM Loan AS loan WHERE loan.lastupdatedtimestamp > :lastupdatedtimestamp", Loan.class);
        q.setParameter("lastupdatedtimestamp", lastupdatedtimestamp);
        return q;
    }
    
    public static TypedQuery<Loan> Loan.findLoansByLastupdatedtimestampIsNotNull() {
        EntityManager em = Loan.entityManager();
        TypedQuery<Loan> q = em.createQuery("SELECT Loan FROM Loan AS loan WHERE loan.lastupdatedtimestamp IS NOT NULL", Loan.class);
        return q;
    }
    
    public static TypedQuery<Loan> Loan.findLoansByLastupdatedtimestampIsNull() {
        EntityManager em = Loan.entityManager();
        TypedQuery<Loan> q = em.createQuery("SELECT Loan FROM Loan AS loan WHERE loan.lastupdatedtimestamp IS NULL", Loan.class);
        return q;
    }
    
    public static TypedQuery<Loan> Loan.findLoansByLastupdatedtimestampLessThan(Date lastupdatedtimestamp) {
        if (lastupdatedtimestamp == null) throw new IllegalArgumentException("The lastupdatedtimestamp argument is required");
        EntityManager em = Loan.entityManager();
        TypedQuery<Loan> q = em.createQuery("SELECT Loan FROM Loan AS loan WHERE loan.lastupdatedtimestamp < :lastupdatedtimestamp", Loan.class);
        q.setParameter("lastupdatedtimestamp", lastupdatedtimestamp);
        return q;
    }
    
    public static TypedQuery<Loan> Loan.findLoansByLoanAmount(BigDecimal loanAmount) {
        if (loanAmount == null) throw new IllegalArgumentException("The loanAmount argument is required");
        EntityManager em = Loan.entityManager();
        TypedQuery<Loan> q = em.createQuery("SELECT Loan FROM Loan AS loan WHERE loan.loanAmount = :loanAmount", Loan.class);
        q.setParameter("loanAmount", loanAmount);
        return q;
    }
    
    public static TypedQuery<Loan> Loan.findLoansByLoanName(String loanName) {
        if (loanName == null || loanName.length() == 0) throw new IllegalArgumentException("The loanName argument is required");
        EntityManager em = Loan.entityManager();
        TypedQuery<Loan> q = em.createQuery("SELECT Loan FROM Loan AS loan WHERE loan.loanName = :loanName", Loan.class);
        q.setParameter("loanName", loanName);
        return q;
    }
    
    public static TypedQuery<Loan> Loan.findLoansByLoanNameLike(String loanName) {
        if (loanName == null || loanName.length() == 0) throw new IllegalArgumentException("The loanName argument is required");
        loanName = loanName.replace('*', '%');
        if (loanName.charAt(0) != '%') {
            loanName = "%" + loanName;
        }
        if (loanName.charAt(loanName.length() - 1) != '%') {
            loanName = loanName + "%";
        }
        EntityManager em = Loan.entityManager();
        TypedQuery<Loan> q = em.createQuery("SELECT Loan FROM Loan AS loan WHERE LOWER(loan.loanName) LIKE LOWER(:loanName)", Loan.class);
        q.setParameter("loanName", loanName);
        return q;
    }
    
    public static TypedQuery<Loan> Loan.findLoansByLoanNeededBy(Date loanNeededBy) {
        if (loanNeededBy == null) throw new IllegalArgumentException("The loanNeededBy argument is required");
        EntityManager em = Loan.entityManager();
        TypedQuery<Loan> q = em.createQuery("SELECT Loan FROM Loan AS loan WHERE loan.loanNeededBy = :loanNeededBy", Loan.class);
        q.setParameter("loanNeededBy", loanNeededBy);
        return q;
    }
    
    public static TypedQuery<Loan> Loan.findLoansByLoanNeededByBetween(Date minLoanNeededBy, Date maxLoanNeededBy) {
        if (minLoanNeededBy == null) throw new IllegalArgumentException("The minLoanNeededBy argument is required");
        if (maxLoanNeededBy == null) throw new IllegalArgumentException("The maxLoanNeededBy argument is required");
        EntityManager em = Loan.entityManager();
        TypedQuery<Loan> q = em.createQuery("SELECT Loan FROM Loan AS loan WHERE loan.loanNeededBy BETWEEN :minLoanNeededBy AND :maxLoanNeededBy", Loan.class);
        q.setParameter("minLoanNeededBy", minLoanNeededBy);
        q.setParameter("maxLoanNeededBy", maxLoanNeededBy);
        return q;
    }
    
    public static TypedQuery<Loan> Loan.findLoansByLoanNeededByGreaterThan(Date loanNeededBy) {
        if (loanNeededBy == null) throw new IllegalArgumentException("The loanNeededBy argument is required");
        EntityManager em = Loan.entityManager();
        TypedQuery<Loan> q = em.createQuery("SELECT Loan FROM Loan AS loan WHERE loan.loanNeededBy > :loanNeededBy", Loan.class);
        q.setParameter("loanNeededBy", loanNeededBy);
        return q;
    }
    
    public static TypedQuery<Loan> Loan.findLoansByLoanNeededByGreaterThanEquals(Date loanNeededBy) {
        if (loanNeededBy == null) throw new IllegalArgumentException("The loanNeededBy argument is required");
        EntityManager em = Loan.entityManager();
        TypedQuery<Loan> q = em.createQuery("SELECT Loan FROM Loan AS loan WHERE loan.loanNeededBy >= :loanNeededBy", Loan.class);
        q.setParameter("loanNeededBy", loanNeededBy);
        return q;
    }
    
    public static TypedQuery<Loan> Loan.findLoansByLoanNeededByLessThan(Date loanNeededBy) {
        if (loanNeededBy == null) throw new IllegalArgumentException("The loanNeededBy argument is required");
        EntityManager em = Loan.entityManager();
        TypedQuery<Loan> q = em.createQuery("SELECT Loan FROM Loan AS loan WHERE loan.loanNeededBy < :loanNeededBy", Loan.class);
        q.setParameter("loanNeededBy", loanNeededBy);
        return q;
    }
    
    public static TypedQuery<Loan> Loan.findLoansByLoanStatusId(Loanstatus loanStatusId) {
        if (loanStatusId == null) throw new IllegalArgumentException("The loanStatusId argument is required");
        EntityManager em = Loan.entityManager();
        TypedQuery<Loan> q = em.createQuery("SELECT Loan FROM Loan AS loan WHERE loan.loanStatusId = :loanStatusId", Loan.class);
        q.setParameter("loanStatusId", loanStatusId);
        return q;
    }
    
    public static TypedQuery<Loan> Loan.findLoansByUserId(User userId) {
        if (userId == null) throw new IllegalArgumentException("The userId argument is required");
        EntityManager em = Loan.entityManager();
        TypedQuery<Loan> q = em.createQuery("SELECT Loan FROM Loan AS loan WHERE loan.userId = :userId", Loan.class);
        q.setParameter("userId", userId);
        return q;
    }
    
}
